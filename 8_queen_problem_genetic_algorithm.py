# -*- coding: utf-8 -*-
"""8_queen_problem_Genetic_Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11HmKfa0qfvgIFV3KAU2fKHGNurxbD2tj
"""

import random
import numpy as np

def random_population_members(value):
  x=[]
  for i in range(value):
    x.append(random.randint(1,value))
  return x

#fitness function
def fitness(members):
  #for horizontal collision
  hor_x=[]
  for value in members:
    hor_x.append(members.count(value)-1) # minus 1 to eliminate unique or single values
  hor_x_collision=sum(hor_x)/2
  #for diagonal collision
  #dx finds the horizontal distance between two columns
  #dy finds the vertical distance between two rows
  #if dx=dy then they collide
  dia_collision=0
  for a in range(len(members)):
    for b in range(len(members)):
        if (a!=b):
            dx=abs(a-b)
            dy=abs(members[a]-members[b])
            if (dx==dy):
                dia_collision+=1
  return int(maxFitness-(hor_x_collision+(dia_collision/2)))


def fitness_probability(members):
  return fitness(members)/total_fitness

#selecting parent
def selection(population, probability):
  select=np.random.choice(len(population), 1, p=probability)
  choice=[]
  for i in select:
    choice.append(population[i])
  return choice
   
def new_child(x,y):
  a=np.array(x)
  b=np.array(y)
  n=a.shape[1]
  a=a.flatten()
  b=b.flatten()
  cross_point=random.randint(0,n-1)
  x=np.concatenate([a[0:cross_point],b[cross_point:n]])
  return x

def mutate(child):
  n=len(child)
  rand_index=random.randint(0,n-1)
  rand_value=random.randint(1,n)
  child[rand_index]=rand_value
  return child

#doing the genetic queen
def queen(population, probability):
  mutation_threshold = 0.3
  next_population=[]
  for i in range(len(population)):
    x=selection(population, probability)
    y=selection(population, probability)
    new=new_child(x,y)
    if random.random()<mutation_threshold:
      new=mutate(new)
    new=np.array(new).tolist()  
    next_population.append(new)
  return next_population

#main
q=8
maxFitness=(q*(q-1))/2  # max fitness for 8 queen = 8*7/2 = 28
population=[]
fittest=[]
a=0;
for i in range(4):
 population.append(random_population_members(q))
generation = 1
while (1):
  fitness_all=[]
  for i in range(len(population)):
    fitness_all.append(fitness(population[i]))
  fittest=fitness_all
  for i in range(len(fitness_all)):
    if (maxFitness==fitness_all[i]):
      a=i; 
      break
  if(maxFitness==fitness_all[a]): break # maxFitness of 28 of a child found
  total_fitness=sum(fitness_all)
  population_probability_list=[]
  for i in range(len(population)):
    population_probability_list.append(fitness_probability((population[i])))
  print("Generation", generation)  
  print("Population", population)
  print("Probability", population_probability_list)
  population=queen(population,population_probability_list)
  generation+=1
print("Generation of miracles", generation)
print("The Apex Population", population)
print("Survival of the fittest", fittest)